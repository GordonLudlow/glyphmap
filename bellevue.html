<!DOCTYPE html>
<html>
<head>
<title>Bellevue Portals</title>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<style type="text/css">
html { height: 100% }
body { height: 100%; margin: 0; padding: 0 }
</style>

<script type="text/javascript">
var portal;
var portalCount;
var mapInitialized=false;

// https://github.com/indy256/convexhull-js/blob/master/convexhull.js
(function () {
    'use strict';

    function convexHull(points) {
        points.sort(function (a, b) {
            return a.x != b.x ? a.x - b.x : a.y - b.y;
        });

        var n = points.length;
        var hull = [];

        for (var i = 0; i < 2 * n; i++) {
            var j = i < n ? i : 2 * n - 1 - i;
            while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], points[j]))
                hull.pop();
            hull.push(points[j]);
        }

        hull.pop();
        return hull;
    }

    function removeMiddle(a, b, c) {
        var cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
        var dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
        return cross < 0 || cross == 0 && dot <= 0;
    }

    // export as AMD module / Node module / browser or worker variable
    if (typeof define === 'function' && define.amd) define(function () { return convexHull; });
    else if (typeof module !== 'undefined') module.exports = convexHull;
    else if (typeof self !== 'undefined') self.convexHull = convexHull;
    else window.convexHull = convexHull;
})();

function renderPortals() {
    //                     A
    // B                                       C
    //           D                   E
    //                     F
    //           G                   H
    // I                                       J
    //                     K
    //
    // A = (56,   0) => (14,  0)
    // B = (0,   32) => ( 0,  8)
    // C = (112, 32) => (28,  8)
    // D = (28,  48) => ( 7, 12)
    // E = (84,  48) => (21, 12)
    // F = (56,  64) => (14, 16)
    // G = (28,  80) => ( 7, 20)
    // H = (84,  80) => (21, 20)
    // I = (0,   96) => ( 0, 24)
    // J = (112, 96) => (28, 24)
    // K = (56, 128) => (14, 32)
    
    // Concentric convex hulls would be a good start.  ABCIJK are on an outer hull.  DEGH an inner hull.  F is a center point.
    // Outlying points can be discarded to get the right shape.
    
    // Or... maybe it's not convex hulls, maybe it's finding colinear points BDFHJ and CEFGI (each 8.06 units apart)and AFK (each 16 units apart)
    // sqrt(7^2 + 4^2) = sqrt(65) = sqrt(5*13) = 8.0622577483-ish
    // It would probably look right if AFK distances were just double the other distances.
    // Or use squared distances of 65 and 256.  (64 and 256 would be 4 times the squared distance)
    
    // a latitude difference of 0.000068 looks pretty level (horizontal line)
    
    // Angle of BDFHJ
    // dx = 7, dy = 4
    // latitude increases to the north (around here) and longitude increases to the east
    // so from B to D, we want lat to decrease and lng to increase and we want the lat/long ratio to be 4/7 or the long/lat ratio to be 7/4 = 1.75
    
    // How do we find in our point soup, 5 equally spaced points with dlong/dlat = 1.75?
    // Maybe first find all the points with the right relative slope, partition the set into sets of parallel lines
    
    // The grouping would be... y-intercept.  longitude intercept
    // Given a point, 47.566674,-122.166767
    // The line through it with decreasing latitude and increasing (to 0) longitude with slope 7/4 intercepts (ignoring reality) long=0 
    // at lat = 47.566674 - 4*(122.166767/7) = -22.24290714, so we'd group it with other points that have a long intercept of approx -22.2429
    
    // Then the whole problem can by solved by grouping the points into 3 grouping schemes.  The BDFHJ angle, the CEFGI angle and by equal longitude (AFK).
    // Then... find the best F.
    
    var BDFHJ = {};
    var CEFGI = {};
    var AFK = {};
    
    for (var p=0; p < portalCount; p++) {
        var intercept = (portal[p][0] + (4.0*portal[p][1]/7.0)).toFixed(4);
        if (intercept in BDFHJ) {
            BDFHJ[intercept].push(portal[p]);
        }
        else {
            BDFHJ[intercept] = [portal[p]];
        }
    }
    for (list in BDFHJ) {
        if (BDFHJ[list].length > 1) {
            BDFHJ[list].sort();
            linePoints = BDFHJ[list].map(function (item) {
                return new google.maps.LatLng(item[0], item[1]);
            });            

            var polyLine = new google.maps.Polyline({
                path: linePoints,
                strokeColor: '#FF0000',
                strokeOpacity: 1.0,
                strokeWeight: 2,
                map: map
            });    
        }                
        for (point in BDFHJ[list]) {
            marker = new google.maps.Marker({
                map: map,
                position: new google.maps.LatLng(BDFHJ[list][point][0], BDFHJ[list][point][1])
            });
        }
    }
    
    for (var p=0; p < portalCount; p++) {
        var intercept = (portal[p][0] - (4.0*portal[p][1]/7.0)).toFixed(4); 
        if (intercept in CEFGI) {
            CEFGI[intercept].push(portal[p]);
        }
        else {
            CEFGI[intercept] = [portal[p]];
        }
    }
    for (list in CEFGI) {
        if (CEFGI[list].length > 1) {
            CEFGI[list].sort();
            linePoints = CEFGI[list].map(function (item) {
                return new google.maps.LatLng(item[0], item[1]);
            });            

            var polyLine = new google.maps.Polyline({
                path: linePoints,
                strokeColor: '#FF0000',
                strokeOpacity: 1.0,
                strokeWeight: 2,
                map: map
            });    
        }                
    }        

    for (var p=0; p < portalCount; p++) {
        var intercept = portal[p][1].toFixed(4); 
        if (intercept in AFK) {
            AFK[intercept].push(portal[p]);
        }
        else {
            AFK[intercept] = [portal[p]];
        }
    }
    for (list in AFK) {
        if (AFK[list].length > 1) {
            AFK[list].sort();
            linePoints = AFK[list].map(function (item) {
                return new google.maps.LatLng(item[0], item[1]);
            });            

            var polyLine = new google.maps.Polyline({
                path: linePoints,
                strokeColor: '#FF0000',
                strokeOpacity: 1.0,
                strokeWeight: 2,
                map: map
            });    
        }                
    }  
    
    /* CONVEX HULLERY
    var label = 0;
    var labels = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    
    while (portalCount > 1) {
        var pointArray = portal.map(function (item) {
            var obj = {};
            obj['x'] = item[0];
            obj['y'] = item[1];
            return obj;            
        }); 
        var hullPoints = convexHull(pointArray);
        // the first point in the list is in the bottom right (SE) corner of the hull
        // points follow in counterclockwise order
        
        // Remove these points from the portal set for the next pass of convex hullery
        for( var i=portalCount - 1; i>=0; i--){
            for( var j=0; j<hullPoints.length; j++){
                if(portal[i][0] == hullPoints[j].x && portal[i][1] == hullPoints[j].y){
                    portal.splice(i, 1);
                    portalCount--;
                    j = hullPoints.length;
                }
            }
        }
        
        //Convert to google latlng objects
        hullPoints = hullPoints.map(function (item) {
            return new google.maps.LatLng(item.x, item.y);
        });

        
        var polyHull = new google.maps.Polygon({
            paths: hullPoints,
            strokeColor: '#000',
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: '#000',
            fillOpacity: 0.1
        });

        polyHull.setMap(map);   
        
        
        for (var j=0; j<hullPoints.length; j++){
            var lat = hullPoints[j].lat().toString();
            var lng = hullPoints[j].lng().toString();
            var mapLat = (lat + .001).toString();
            var mapLng = (lng - .001).toString();
            var url = 'https://www.ingress.com/intel?ll=' + mapLat + ',' + mapLng + '&z=17&pll=' + lat + ',' + lng

            var marker;
            
            if (j==0) {
                var pinColor = "75FE69";
                var pinImage = new google.maps.MarkerImage("http://chart.apis.google.com/chart?chst=d_map_pin_letter&chld=" + labels[label % labels.length] + "|" + pinColor,
                    new google.maps.Size(21, 34),
                    new google.maps.Point(0,0),
                    new google.maps.Point(10, 34));
                marker = new google.maps.Marker({
                    map: map,
                    position: hullPoints[j],
                    title: url,
                    url: url,
                    icon: pinImage
                });
            }
            else if (j==1) {
                var pinColor = "7569FE";
                var pinImage = new google.maps.MarkerImage("http://chart.apis.google.com/chart?chst=d_map_pin_letter&chld=" + labels[label % labels.length] + "|" + pinColor,
                    new google.maps.Size(21, 34),
                    new google.maps.Point(0,0),
                    new google.maps.Point(10, 34));
                marker = new google.maps.Marker({
                    map: map,
                    position: hullPoints[j],
                    title: url,
                    url: url,
                    icon: pinImage
                });                
            }
            else {
            
                marker = new google.maps.Marker({
                    map: map,
                    position: hullPoints[j],
                    label: labels[label % labels.length],
                    title: url,
                    url: url
                });
            }
            google.maps.event.addListener(marker, 'click', function() {
                window.location.href = this.url;
            });                
        }
        label++;  
    }
    */
}

function initializeMap() 
{
    if (!mapInitialized)
    {
        // Default map options
        var mapOptions = { center: new google.maps.LatLng(47.65, -122.10),
                            zoom: 10,
                            mapTypeId: google.maps.MapTypeId.ROADMAP };
        
        // Load the map options cookie if there is one
        var name = "mapOptions=";
        var ca = document.cookie.split(';');
        for(var i = 0; i <ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) == 0) {
                mapOptions = JSON.parse(c.substring(name.length));
                break;
            }
        }        
        
        map = new google.maps.Map(document.getElementById("map_canvas"), mapOptions);
        mapInitialized=true;

        // Load the portal coordinates
        var portalRequest=new XMLHttpRequest();
        portalRequest.open("GET",'http://runmap-140616.appspot.com/');
        portalRequest.onreadystatechange = onreadystatechange = function() {
            if (this.readyState == 4) // complete 
            {
                if (this.status == 200) // OK
                {
                    portal = JSON.parse('[' + this.responseText + ']');
                    portalCount = portal.length;
                    renderPortals();
                }
            }
        };
        portalRequest.send();
        
        /*
        for (var i = 0; i < portalCount; i++) {
            var circle = new google.maps.Circle({
                strokeColor: '#FF0000',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: '#FF0000',
                fillOpacity: 0.35,
                map: map,
                center: {lat: portal[i][0], lng: portal[i][1]},
                radius: 40
            });
        }
        */
        
        /*
        // Find a rectangle (just as a test of using lat/long instead of projecting)
        var closest = 1000;
        var rectangle = [0,1,2,3];
        for (var i=0; i<portalCount;i++){
            for (var j=0; j<portalCount;j++){
                if (j==i) continue;
                for (var k=0;k<portalCount;k++){
                    if (k==i || k==j) continue;
                    for (var l=0;l<portalCount;l++){
                        if (l==i || l==j || l==k) continue;
                        // we want the closest i.x == j.x, k.x == l.x, i.y == k.y, j.y == l.y
                        // for rect i, j, l, k(, i)
                        var maxError = Math.max(
                            Math.abs(portal[i][0] - portal[j][0]),
                            Math.abs(portal[k][0] - portal[l][0]),
                            Math.abs(portal[i][1] - portal[k][1]),
                            Math.abs(portal[j][1] - portal[l][1]));
                        if (maxError < closest) {
                            closest = maxError;
                            rectangle = [i,j,k,l];
                        }
                        
                    }
                }
            }
        }

        // Draw the rectangle
        var polyline = new google.maps.Polyline({
                path: [
                {lat: portal[rectangle[0]][0], lng: portal[rectangle[0]][1]},
                {lat: portal[rectangle[1]][0], lng: portal[rectangle[1]][1]},
                {lat: portal[rectangle[3]][0], lng: portal[rectangle[3]][1]},
                {lat: portal[rectangle[2]][0], lng: portal[rectangle[2]][1]},
                {lat: portal[rectangle[0]][0], lng: portal[rectangle[0]][1]}
                ],
                strokeColor: "#FF00FF",
                strokeOpacity: 1.0,
                strokeWeight: 2,
                map: map});
 
        */

        // What I want is...

    } 
}
var saveRequest;
function handleSaveRequest()
{
    console.log("readyState = " + String(saveRequest.readyState) + ", status = " + String(saveRequest.status));
    if (saveRequest.readyState == 4) // complete 
    {
        if (saveRequest.status == 200) // OK
        {
            // Success!
            //window.location.href += "?foo=bar"; //to pass in parameter(s) of the current viewport
        
            // Save current map options so that they'll be retained
            var d = new Date();
            d.setTime(d.getTime() + (7*24*60*60*1000)); // keep it for a week
            var expires = "expires="+d.toUTCString();
            
            var mapOptions = {  center: map.getCenter(),
                                zoom: map.getZoom(),
                                mapTypeId: map.getMapTypeId() };

            document.cookie = "mapOptions=" + JSON.stringify(mapOptions) + "; " + expires;            

            window.location.reload(true);
        }
    }
}
var newPortals = [];

function save() {   
    if (!newPortals.length) {
        document.getElementById('status').innerHTML = 'Nothing to save.  Add some portals.'; 
        return;
    }
    document.getElementById('status').innerHTML = 'Saving...'; 
    
    var data = '[';
    var leadingComma = '';
    for (var p=0; p < newPortals.length; p++) {
        data += leadingComma + '[' + String(newPortals[p][0]) + ',' + String(newPortals[p][1]) + ']';
        leadingComma = ',';
    }
    data += ']';    

    saveRequest=new XMLHttpRequest();
    saveRequest.open('POST', 'http://runmap-140616.appspot.com/');
    saveRequest.setRequestHeader('Content-Type', 'application/json');
    //saveRequest.setRequestHeader('Content-Length', data.length);
    saveRequest.onreadystatechange = handleSaveRequest;
    saveRequest.send(data);
}
//,
//[47.631679,-122.208507]

function add() {
    var enteredPortal = document.getElementById('portalEntry').value;
    if (!enteredPortal) {
        document.getElementById('status').innerHTML = 'Enter portal lat,lng to add'; 
        return;
    }
    // Allow entire intel map link to be pasted in
    //https://www.ingress.com/intel?ll=47.570585,-122.149027&z=17&pll=47.570508,-122.150159
    var pllIndex = enteredPortal.indexOf('pll=');
    if (pllIndex >= 0) {
        enteredPortal = enteredPortal.substring(pllIndex+4)
    }
    var latLng = enteredPortal.split(',');
    if (latLng.length != 2) {
        document.getElementById('status').innerHTML = 'Invalid portal lat,lng'; 
        return;
    }
    latLng[0] = parseFloat(latLng[0])
    latLng[1] = parseFloat(latLng[1])
    for (var p=0; p < portalCount; p++) {
        if ((portal[p][0] == latLng[0]) && (portal[p][1] == latLng[1])) {
            document.getElementById('status').innerHTML = 'Duplicate portal'; 
            return;            
        }
    }
    for (var p=0; p < newPortals.length; p++) {
        if ((newPortals[p][0] == latLng[0]) && (newPortals[p][1] == latLng[1])) {
            document.getElementById('status').innerHTML = 'Already added'; 
            return;            
        }
    }    
    newPortals.push(latLng);

    var pinColor = "75FE69";
    var pinImage = new google.maps.MarkerImage("http://chart.apis.google.com/chart?chst=d_map_pin_letter&chld=o|" + pinColor,
        new google.maps.Size(21, 34),
        new google.maps.Point(0,0),
        new google.maps.Point(10, 34));
    marker = new google.maps.Marker({
        map: map,
        position: new google.maps.LatLng(latLng[0], latLng[1]),
        icon: pinImage
    });
    document.getElementById('status').innerHTML = 'Portal added'; 
    document.getElementById('portalEntry').value = '';
}
</script>
</head>

<body>
<script type="text/javascript"
src="http://maps.googleapis.com/maps/api/js?key=AIzaSyCyM0mrFrvnIbYkve4hWKY30cjVqY8VnMU&callback=initializeMap" async defer>
</script>
<div id="header" style="width:100%; height:10%;overflow:auto;">
<input type="text" id="portalEntry" /> <span id=addPortal><button onclick="add()">Add</button></span><br/>
<span id=status> </span><br/>
<span id=saveButton><button onclick="save()">Save</button></span><br/>
</div>
<div id="map_canvas" style="width:100%; height:90%"></div>
</body>
</html>