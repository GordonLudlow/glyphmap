<!DOCTYPE html>
<html>
<head>
<title>Bellevue Portals</title>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<style type="text/css">
html { height: 100% }
body { height: 100%; margin: 0; padding: 0 }
</style>

<script type="text/javascript">
var portal;
var portalCount;
var mapInitialized=false;

// https://github.com/indy256/convexhull-js/blob/master/convexhull.js
(function () {
    'use strict';

    function convexHull(points) {
        points.sort(function (a, b) {
            return a.x != b.x ? a.x - b.x : a.y - b.y;
        });

        var n = points.length;
        var hull = [];

        for (var i = 0; i < 2 * n; i++) {
            var j = i < n ? i : 2 * n - 1 - i;
            while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], points[j]))
                hull.pop();
            hull.push(points[j]);
        }

        hull.pop();
        return hull;
    }

    function removeMiddle(a, b, c) {
        var cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
        var dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
        return cross < 0 || cross == 0 && dot <= 0;
    }

    // export as AMD module / Node module / browser or worker variable
    if (typeof define === 'function' && define.amd) define(function () { return convexHull; });
    else if (typeof module !== 'undefined') module.exports = convexHull;
    else if (typeof self !== 'undefined') self.convexHull = convexHull;
    else window.convexHull = convexHull;
})();

function saveMapOptions() {
    // Save current map options so that they'll be retained
    var d = new Date();
    d.setTime(d.getTime() + (7*24*60*60*1000)); // keep it for a week
    var expires = "expires="+d.toUTCString();

    var mapOptions = {  center: map.getCenter(),
                        zoom: map.getZoom(),
                        mapTypeId: map.getMapTypeId() };

    document.cookie = "mapOptions=" + JSON.stringify(mapOptions) + "; " + expires;   
}

function findAdjacent(adjacent, rise, run) {
    var interceptMap = {};
    for (var p=0; p < portalCount; p++) {
        if (rise==0) {
            var intercept = (portal[p][0]).toFixed(4);
        }
        else if (run==0) {
            var intercept = (portal[p][1]).toFixed(4);
        }
        else {
            var intercept = (portal[p][0] + (rise*portal[p][1]/run)).toFixed(4);
        }
        if (intercept in interceptMap) {
            interceptMap[intercept].push(p);
        }
        else {
            interceptMap[intercept] = [p];
        }        
    } 
    if (rise==0) {
        var compare = function(a, b) { return portal[a][1] - portal[b][1]; };
    }
    else {
        var compare = function(a, b) { return portal[a][0] - portal[b][0]; };
    }    
    for (var list in interceptMap) {
        if (interceptMap[list].length > 1) {
            interceptMap[list].sort(compare); 
            for (var i=0; i<interceptMap[list].length-1; i++) {
                var p0 = interceptMap[list][i];
                for (var j=i+1; j<interceptMap[list].length; j++) {
                    var p1 = interceptMap[list][j];
                    adjacent[p0][p1] = [rise,run];
                    adjacent[p1][p0] = [-rise,-run];
                }
            }
        }
    }
}

function CompareArrays(a1, a2) {
    if (a1 && !a2)
        return 1;
    if (!a1 && a2)
        return -1;
    if (!a1 && !a2)
        return 0;
        
    // compare lengths - can save a lot of time 
    var lengthDiff = a1.length - a2.length; 
    if (lengthDiff)
        return lengthDiff;

    for (var i = 0, l=a1.length; i < l; i++) {
        // Check if we have nested arrays
        if (a1[i] instanceof Array && a2[i] instanceof Array) {
            // recurse into the nested arrays
            var diff = CompareArrays(a1[i], a2[i]);
            if (diff)
                return diff;       
        }           
        else {
            var diff = a1[i] - a2[i];
            if (diff)
                return diff;
        }           
    }       
    return 0;
}
            
function renderPortals() {
    for (var point=0; point<portalCount; point++) {
        var lat = portal[point][0];
        var lng = portal[point][1];
        var mapLat = (lat + .001).toString();
        var mapLng = (lng - .001).toString();
        var url = 'https://www.ingress.com/intel?ll=' + mapLat + ',' + mapLng + '&z=17&pll=' + lat + ',' + lng;

        marker = new google.maps.Marker({
            map: map,
            title: url,
            url: url,                
            position: new google.maps.LatLng(lat, lng)
        });
        google.maps.event.addListener(marker, 'click', function() {
            saveMapOptions();
            window.location.href = this.url;
        });              
    }

    //                     A
    // B                                       C
    //           D                   E
    //                     F
    //           G                   H
    // I                                       J
    //                     K
    //
    // A = (56,   0) => (14,  0)
    // B = (0,   32) => ( 0,  8)
    // C = (112, 32) => (28,  8)
    // D = (28,  48) => ( 7, 12)
    // E = (84,  48) => (21, 12)
    // F = (56,  64) => (14, 16)
    // G = (28,  80) => ( 7, 20)
    // H = (84,  80) => (21, 20)
    // I = (0,   96) => ( 0, 24)
    // J = (112, 96) => (28, 24)
    // K = (56, 128) => (14, 32)
    
    // Concentric convex hulls would be a good start.  ABCIJK are on an outer hull.  DEGH an inner hull.  F is a center point.
    // Outlying points can be discarded to get the right shape.
    
    // Or... maybe it's not convex hulls, maybe it's finding colinear points BDFHJ and CEFGI (each 8.06 units apart)and AFK (each 16 units apart)
    // sqrt(7^2 + 4^2) = sqrt(65) = sqrt(5*13) = 8.0622577483-ish
    // It would probably look right if AFK distances were just double the other distances.
    // Or use squared distances of 65 and 256.  (64 and 256 would be 4 times the squared distance)
    
    // a latitude difference of 0.000068 looks pretty level (horizontal line)
    
    // Angle of BDFHJ
    // dx = 7, dy = 4
    // latitude increases to the north (around here) and longitude increases to the east
    // so from B to D, we want lat to decrease and lng to increase and we want the lat/long ratio to be 4/7 or the long/lat ratio to be 7/4 = 1.75
    
    // How do we find in our point soup, 5 equally spaced points with dlong/dlat = 1.75?
    // Maybe first find all the points with the right relative slope, partition the set into sets of parallel lines
    
    // The grouping would be... y-intercept.  longitude intercept
    // Given a point, 47.566674,-122.166767
    // The line through it with decreasing latitude and increasing (to 0) longitude with slope 7/4 intercepts (ignoring reality) long=0 
    // at lat = 47.566674 - 4*(122.166767/7) = -22.24290714, so we'd group it with other points that have a long intercept of approx -22.2429
    
    // Then the whole problem can by solved by grouping the points into 3 grouping schemes.  The BDFHJ angle, the CEFGI angle and by equal longitude (AFK).
    // Then... find the best F.
    
    //var BDFHJ = {};
    //var CEFGI = {};
    //var AFK = {}; // vertical
    //var DE = {}; // horizontal
    
    // Need a better data structure
    // For each of the angles of interest, find adjacency.  Put it in an adgacency graph.
    
    var adjacency =[]; // for each pair of portals, the slope of the line between them
                       // the slope is expressed as a tuple indicating direction
                       // (up or down) one of the interesting lines
                       // If the pair of points is along BDFHJ, B's adjacency to D is 4,7.
                       // D's adjacency to B is -4,-7 (same slope, opposite direction)
    while (adjacency.push([]) < portalCount);
    for (var p0=0; p0<portalCount; p0++) {
        for (var p1=0; p1<portalCount; p1++) {
            adjacency[p0][p1] = [0,0];
        }
    }
    
    var sqDist =[]; 
    var dist = [];
    while (sqDist.push([]) < portalCount);
    while (dist.push([]) < portalCount);
    for (var p0=0; p0<portalCount; p0++) {
        for (var p1=0; p1<portalCount; p1++) {
            sqDist[p0][p1] = 0;
            dist[p0][p1] = 0;
        }
    }    
    
    findAdjacent(adjacency,  4, 7);
    findAdjacent(adjacency, -4, 7);
    findAdjacent(adjacency,  1, 0);
    findAdjacent(adjacency,  0, 1);



    //linePoints = AFK[list].map(function (item) {
    //    return new google.maps.LatLng(item[0], item[1]);
    //});            

    //var polyLine = new google.maps.Polyline({
    //    path: linePoints,
    //    strokeColor: '#FF0000',
    //    strokeOpacity: 1.0,
    //    strokeWeight: 2,
    //    map: map
    //});    
 
    // Find F candidates
    /*
    var candidates = 0;
    for (b in BDFHJ) {
        if (BDFHJ[b].length >= 5) {
            for (c in CEFGI) {
                if (CEFGI[c].length >= 5) {
                    for (a in AFK) {
                        if (AFK[a].length >= 3) {
                            for (bi in BDFHJ[b]) {
                                for (ci in CEFGI[c]) {
                                    if (BDFHJ[b][bi][2] == CEFGI[c][ci][2]) {
                                        for (ai in AFK[a]) {
                                            if (AFK[a][ai][2] == BDFHJ[b][bi][2]) {
                                                // Found a candidate!
                                                var circle = new google.maps.Circle({
                                                    strokeColor: '#00FF00',
                                                    strokeOpacity: 0.8,
                                                    strokeWeight: 2,
                                                    fillColor: '#FF0000',
                                                    fillOpacity: 0.35,
                                                    map: map,
                                                    center: {lat: AFK[a][ai][0], lng: AFK[a][ai][1]},
                                                    radius: 40});                                                
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    */
    
    // No F candidates yet, try something simpler
    // "Truth" is DFHEFGD 
    //                     A
    // B                                       C
    //           D                   E
    //                     F
    //           G                   H
    // I                                       J
    //                     K    

   
    // "Truth" is DFHEFGD 
    //                     A
    // B                                       C
    //           D                   E
    //                     F
    //           G                   H
    // I                                       J
    //                     K    
    //
    // Which is down-right, down-right, up, down-left, down-left, up.
    // For each point, can you go up, down, left, right, up-left, up-right, down-left, down-right?
    // (later there will be more angles, like B->G and I->D->A, but this is a start)
    
    // Strong is simpler: down, right, up, left as a closed curve
    //for (p in portal) {
    //    if (AFK[portal[p][5]].length > 1) {
    //    }
    //}
    
    /*
    var path = ['down', 'right', 'up', 'left'];
    var iPath = 0;
    var stack = [];
    for (a in AFK) {
        if (AFK[a].length == 1) continue; 
        for (ai = 0; ai<AFK[a].length-1; ai++) {
            for (aj = ai+1; aj<AFK[a].length; aj++) {
                // ai->aj is a down stroke that's a possible beginning of the glyph
                stack.push();
            }
        }
        
    }
    */
    
    
    
    var up = [1,0];
    var down = [-1,0];
    var right = [0,1];
    var left = [0,-1];
    var downRight47 = [-4,-7];
    var upLeft47 = [4,7];
    
    //var path = [[-1,0],[0,1]];  // down, right
    var path = [down,downRight47]; // barrier: down, down-right
    var sqPixelDist = [16*16, 14*14 + 8*8];
    var pixelDist = [Math.sqrt(sqPixelDist[0]), Math.sqrt(sqPixelDist[1])];

    var stack = [];
    for (var p0=0; p0<portalCount; p0++) {
        for (var p1=0; p1<portalCount; p1++) {
            if (!CompareArrays(adjacency[p0][p1], path[0])) {
                stack.push([p0,p1]);
            }
        }
    }
    var minError = Number.MAX_VALUE;
    while (stack.length) {
        var partialPath = stack.pop();
        var partialPathLength = partialPath.length;
        for (var p=0; p<portalCount; p++) {
            if (!CompareArrays(adjacency[partialPath[partialPathLength-1]][p], path[partialPathLength-1])) {
                var extendedPath = partialPath.slice();
                extendedPath.push(p);
                if (partialPathLength < path.length) {
                    stack.push(extendedPath);
                }
                else {
                    // Found full length path with the correct turns
                    
                    // Is it long enough?
                    if (path.length < 5) {
                        // The glyph itself doesn't have 6 points, are there extra itermediary points?
                        var intermediates = 0;
                        //var intermediateCenters = [];
                        for (var epi=0; epi<partialPathLength;epi++) {
                            for (var pi=0; pi<portalCount; pi++) {
                                if (!CompareArrays(adjacency[extendedPath[epi]][pi], path[epi])
                                    && !CompareArrays(adjacency[pi][extendedPath[epi+1]], path[epi])) {
                                    intermediates++;

                        //            intermediateCenters.push({lat: portal[pi][0], lng: portal[pi][1]});
                               
                                }
                            }
                        }
                        if (path.length + intermediates < 5) {
                            continue;
                        }
                        //for (center in intermediateCenters) {
                        //    var circle = new google.maps.Circle({
                        //        strokeColor: '#FF0000',
                        //        strokeOpacity: 0.8,
                        //        strokeWeight: 2,
                        //        fillColor: '#FF0000',
                        //        fillOpacity: 0.35,
                        //        map: map,
                        //        center: intermediateCenters[center],
                        //        radius: 30}); 
                        }//                                
                    }
                    
                    // Compare relative segment lengths
                    
                    // First, make sure we have all the squared distances calculated
                    for (var ppi=0;ppi<partialPathLength;ppi++) {
                        // find the dist between points if it's not in the sqDist cache
                        if (!sqDist[extendedPath[ppi]][extendedPath[ppi+1]]) {
                            var dlat = portal[extendedPath[ppi]][0] - portal[extendedPath[ppi+1]][0];
                            var dlng = portal[extendedPath[ppi]][1] - portal[extendedPath[ppi+1]][1];
                            sqDist[extendedPath[ppi]][extendedPath[ppi+1]] = dlat*dlat + dlng*dlng;
                            dist[extendedPath[ppi]][extendedPath[ppi+1]] = Math.sqrt(sqDist[extendedPath[ppi]][extendedPath[ppi+1]]);
                        }
                    }
                    
                    // use the first segment's length as the ratio of pixels squared distance to lat,lng squared distance
                    var ratio = dist[partialPath[0]][partialPath[1]] / pixelDist[0];
                    var error = 0;
                    for (var ppi=1;ppi<partialPathLength;ppi++) {
                        var delta = (pixelDist[ppi] * ratio) - dist[extendedPath[ppi]][extendedPath[ppi+1]];
                        error += delta;
                    }
                    if (error < minError) {
                        minError = error;
                        var bestPath = extendedPath.slice();
                    }
                    //var linePoints = extendedPath.map(function (item) {
                    //    return new google.maps.LatLng(portal[item][0], portal[item][1]);
                    //});            

                    //var polyLine = new google.maps.Polyline({
                    //    path: linePoints,
                    //    strokeColor: '#00FF00',
                    //    strokeOpacity: 1.0,
                    //    strokeWeight: 20,
                    //    map: map
                    //});                    
                }
            }
        }
    }

    var linePoints = bestPath.map(function (item) {
        return new google.maps.LatLng(portal[item][0], portal[item][1]);
    });            

    var polyLine = new google.maps.Polyline({
        path: linePoints.slice(0,2),
        strokeColor: '#FF0000',
        strokeOpacity: 1.0,
        strokeWeight: 2,
        map: map
    });
    var polyLine2 = new google.maps.Polyline({
        path: linePoints.slice(1),
        strokeColor: '#0000FF',
        strokeOpacity: 1.0,
        strokeWeight: 2,
        map: map
    });    
    
    
    /* CONVEX HULLERY
    var label = 0;
    var labels = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    
    while (portalCount > 1) {
        var pointArray = portal.map(function (item) {
            var obj = {};
            obj['x'] = item[0];
            obj['y'] = item[1];
            return obj;            
        }); 
        var hullPoints = convexHull(pointArray);
        // the first point in the list is in the bottom right (SE) corner of the hull
        // points follow in counterclockwise order
        
        // Remove these points from the portal set for the next pass of convex hullery
        for( var i=portalCount - 1; i>=0; i--){
            for( var j=0; j<hullPoints.length; j++){
                if(portal[i][0] == hullPoints[j].x && portal[i][1] == hullPoints[j].y){
                    portal.splice(i, 1);
                    portalCount--;
                    j = hullPoints.length;
                }
            }
        }
        
        //Convert to google latlng objects
        hullPoints = hullPoints.map(function (item) {
            return new google.maps.LatLng(item.x, item.y);
        });

        
        var polyHull = new google.maps.Polygon({
            paths: hullPoints,
            strokeColor: '#000',
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: '#000',
            fillOpacity: 0.1
        });

        polyHull.setMap(map);   
        
        
        for (var j=0; j<hullPoints.length; j++){
            var lat = hullPoints[j].lat().toString();
            var lng = hullPoints[j].lng().toString();
            var mapLat = (lat + .001).toString();
            var mapLng = (lng - .001).toString();
            var url = 'https://www.ingress.com/intel?ll=' + mapLat + ',' + mapLng + '&z=17&pll=' + lat + ',' + lng

            var marker;
            
            if (j==0) {
                var pinColor = "75FE69";
                var pinImage = new google.maps.MarkerImage("http://chart.apis.google.com/chart?chst=d_map_pin_letter&chld=" + labels[label % labels.length] + "|" + pinColor,
                    new google.maps.Size(21, 34),
                    new google.maps.Point(0,0),
                    new google.maps.Point(10, 34));
                marker = new google.maps.Marker({
                    map: map,
                    position: hullPoints[j],
                    title: url,
                    url: url,
                    icon: pinImage
                });
            }
            else if (j==1) {
                var pinColor = "7569FE";
                var pinImage = new google.maps.MarkerImage("http://chart.apis.google.com/chart?chst=d_map_pin_letter&chld=" + labels[label % labels.length] + "|" + pinColor,
                    new google.maps.Size(21, 34),
                    new google.maps.Point(0,0),
                    new google.maps.Point(10, 34));
                marker = new google.maps.Marker({
                    map: map,
                    position: hullPoints[j],
                    title: url,
                    url: url,
                    icon: pinImage
                });                
            }
            else {
            
                marker = new google.maps.Marker({
                    map: map,
                    position: hullPoints[j],
                    label: labels[label % labels.length],
                    title: url,
                    url: url
                });
            }
            google.maps.event.addListener(marker, 'click', function() {
                window.location.href = this.url;
            });                
        }
        label++;  
    }
    */
}

function initializeMap() 
{
    if (!mapInitialized)
    {
        // Default map options
        var mapOptions = { center: new google.maps.LatLng(47.65, -122.10),
                            zoom: 10,
                            mapTypeId: google.maps.MapTypeId.ROADMAP };
        
        // Load the map options cookie if there is one
        var name = "mapOptions=";
        var ca = document.cookie.split(';');
        for(var i = 0; i <ca.length; i++) {
            var c = ca[i].trim();
            if (c.indexOf(name) == 0) {
                mapOptions = JSON.parse(c.substring(name.length));
                break;
            }
        }        
        
        map = new google.maps.Map(document.getElementById("map_canvas"), mapOptions);
        mapInitialized=true;

        // Load the portal coordinates
        var portalRequest=new XMLHttpRequest();
        portalRequest.open("GET",'http://runmap-140616.appspot.com/');
        portalRequest.onreadystatechange = onreadystatechange = function() {
            if (this.readyState == 4) // complete 
            {
                if (this.status == 200) // OK
                {
                    portal = JSON.parse('[' + this.responseText + ']');
                    portalCount = portal.length;
                    for (var p=0; p<portalCount;p++) {
                        portal[p].push(p); // the index will be handy for comparing elements
                    }
                    renderPortals();
                }
            }
        };
        portalRequest.send();
        
        /*
        for (var i = 0; i < portalCount; i++) {
            var circle = new google.maps.Circle({
                strokeColor: '#FF0000',
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: '#FF0000',
                fillOpacity: 0.35,
                map: map,
                center: {lat: portal[i][0], lng: portal[i][1]},
                radius: 40
            });
        }
        */
        
        /*
        // Find a rectangle (just as a test of using lat/long instead of projecting)
        var closest = 1000;
        var rectangle = [0,1,2,3];
        for (var i=0; i<portalCount;i++){
            for (var j=0; j<portalCount;j++){
                if (j==i) continue;
                for (var k=0;k<portalCount;k++){
                    if (k==i || k==j) continue;
                    for (var l=0;l<portalCount;l++){
                        if (l==i || l==j || l==k) continue;
                        // we want the closest i.x == j.x, k.x == l.x, i.y == k.y, j.y == l.y
                        // for rect i, j, l, k(, i)
                        var maxError = Math.max(
                            Math.abs(portal[i][0] - portal[j][0]),
                            Math.abs(portal[k][0] - portal[l][0]),
                            Math.abs(portal[i][1] - portal[k][1]),
                            Math.abs(portal[j][1] - portal[l][1]));
                        if (maxError < closest) {
                            closest = maxError;
                            rectangle = [i,j,k,l];
                        }
                        
                    }
                }
            }
        }

        // Draw the rectangle
        var polyline = new google.maps.Polyline({
                path: [
                {lat: portal[rectangle[0]][0], lng: portal[rectangle[0]][1]},
                {lat: portal[rectangle[1]][0], lng: portal[rectangle[1]][1]},
                {lat: portal[rectangle[3]][0], lng: portal[rectangle[3]][1]},
                {lat: portal[rectangle[2]][0], lng: portal[rectangle[2]][1]},
                {lat: portal[rectangle[0]][0], lng: portal[rectangle[0]][1]}
                ],
                strokeColor: "#FF00FF",
                strokeOpacity: 1.0,
                strokeWeight: 2,
                map: map});
 
        */

        // What I want is...

    } 
}
var saveRequest;
function handleSaveRequest()
{
    console.log("readyState = " + String(saveRequest.readyState) + ", status = " + String(saveRequest.status));
    if (saveRequest.readyState == 4) // complete 
    {
        if (saveRequest.status == 200) // OK
        {
            // Success!
            //window.location.href += "?foo=bar"; //to pass in parameter(s) of the current viewport
        
            // Save current map options so that they'll be retained
            saveMapOptions();
         
            window.location.reload(true);
        }
    }
}
var newPortals = [];

function save() {   
    if (!newPortals.length) {
        document.getElementById('status').innerHTML = 'Nothing to save.  Add some portals.'; 
        return;
    }
    document.getElementById('status').innerHTML = 'Saving...'; 
    
    var data = '[';
    var leadingComma = '';
    for (var p=0; p < newPortals.length; p++) {
        data += leadingComma + '[' + String(newPortals[p][0]) + ',' + String(newPortals[p][1]) + ']';
        leadingComma = ',';
    }
    data += ']';    

    saveRequest=new XMLHttpRequest();
    saveRequest.open('POST', 'http://runmap-140616.appspot.com/');
    saveRequest.setRequestHeader('Content-Type', 'application/json');
    //saveRequest.setRequestHeader('Content-Length', data.length);
    saveRequest.onreadystatechange = handleSaveRequest;
    saveRequest.send(data);
}
//,
//[47.631679,-122.208507]

function addPortal(latLng) {
    newPortals.push(latLng);

    var pinColor = "75FE69";
    var pinImage = new google.maps.MarkerImage("http://chart.apis.google.com/chart?chst=d_map_pin_letter&chld=o|" + pinColor,
        new google.maps.Size(21, 34),
        new google.maps.Point(0,0),
        new google.maps.Point(10, 34));
    marker = new google.maps.Marker({
        map: map,
        position: new google.maps.LatLng(latLng[0], latLng[1]),
        icon: pinImage
    });
}

function add() {
    var enteredPortal = document.getElementById('portalEntry').value;
    if (!enteredPortal) {
        document.getElementById('status').innerHTML = 'Enter portal lat,lng to add'; 
        return;
    }
    // Allow entire intel map link to be pasted in
    //https://www.ingress.com/intel?ll=47.570585,-122.149027&z=17&pll=47.570508,-122.150159
    var pllIndex = enteredPortal.indexOf('pll=');
    if (pllIndex >= 0) {
        enteredPortal = enteredPortal.substring(pllIndex+4)
    }
    var latLng = enteredPortal.split(',');
    if (latLng.length != 2) {
        document.getElementById('status').innerHTML = 'Invalid portal lat,lng'; 
        return;
    }
    latLng[0] = parseFloat(latLng[0])
    latLng[1] = parseFloat(latLng[1])
    if (isNaN(latLng[0]) || isNaN(latLng[1])) {
        document.getElementById('status').innerHTML = 'Invalid portal lat,lng'; 
        return;
    }
    for (var p=0; p < portalCount; p++) {
        if ((portal[p][0] == latLng[0]) && (portal[p][1] == latLng[1])) {
            document.getElementById('status').innerHTML = 'Duplicate portal'; 
            return;            
        }
    }
    for (var p=0; p < newPortals.length; p++) {
        if ((newPortals[p][0] == latLng[0]) && (newPortals[p][1] == latLng[1])) {
            document.getElementById('status').innerHTML = 'Already added'; 
            return;            
        }
    }
    
    // Check to make sure it's in Bellevue
    // TODO some day: If this even works, stick the city into the database and do this in other cities
    addRequest=new XMLHttpRequest();
    addRequest.open('GET', 'https://maps.googleapis.com/maps/api/geocode/json?latlng='
        + latLng[0] + ',' + latLng[1] + '&result_type=locality&key=AIzaSyASf7qjepsI9SUnp2Y5_RRlesn132jfA18');
    addRequest.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            result = JSON.parse(this.responseText);
            if (result.status == 'ZERO_RESULTS') {
                document.getElementById('status').innerHTML = 'Google reverse geocoding failed.  Added portal anyway.';
                addPortal(latLng);
                return;
            }
            if (result.status != 'OK') {
                document.getElementById('status').innerHTML = result.status; 
                return;
            }
            var resultCount = result.results.length;
            for (var r = 0; r<resultCount; r++) {
                var componentCount = result.results[r].address_components.length;
                for (var c =0; c<componentCount; c++) {
                    if (result.results[r].address_components[c].short_name == 'Bellevue') {
                        addPortal(latLng);

                        document.getElementById('status').innerHTML = 'Portal added'; 
                        document.getElementById('portalEntry').value = '';
                        return;
                    }
                }
            }
            document.getElementById('status').innerHTML = 'Not in bellevue'; 
        }
    };
    addRequest.send();  
}
</script>
</head>

<body>
<script type="text/javascript"
src="http://maps.googleapis.com/maps/api/js?key=AIzaSyCyM0mrFrvnIbYkve4hWKY30cjVqY8VnMU&callback=initializeMap" async defer>
</script>
<div id="header" style="width:100%; height:10%;overflow:auto;">
<input type="text" id="portalEntry" /> <span id=addPortal><button onclick="add()">Add</button></span><br/>
<span id=status> </span><br/>
<span id=saveButton><button onclick="save()">Save</button></span><br/>
</div>
<div id="map_canvas" style="width:100%; height:90%"></div>
</body>
</html>